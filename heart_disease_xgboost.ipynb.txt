
# Heart Disease Prediction with Cross-Validation (Colab-ready)


# Upload ZIP file in Colab
from google.colab import files
uploaded = files.upload()

import zipfile
import io
import os
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, cross_val_score, StratifiedKFold
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from xgboost import XGBClassifier
from sklearn.metrics import classification_report, confusion_matrix, roc_auc_score, roc_curve, auc

#  Load dataset from uploaded ZIP
zip_filename = list(uploaded.keys())[0]  # get the uploaded file name
zip_ref = zipfile.ZipFile(io.BytesIO(uploaded[zip_filename]), 'r')
zip_ref.extractall()
zip_ref.close()

# Find CSV inside extracted files
csv_files = [f for f in os.listdir() if f.endswith('.csv')]
if len(csv_files) == 0:
    raise FileNotFoundError("No CSV file found in the ZIP.")
csv_filename = csv_files[0]
print(f"Using CSV file: {csv_filename}")

# Load CSV
df = pd.read_csv(csv_filename)
print("Dataset preview:")
display(df.head())

# Separate features and target
X = df.drop("HeartDisease", axis=1)
Y = df["HeartDisease"]

#  Identify categorical and numeric columns
cat_col = X.select_dtypes(include='object').columns.tolist()
num_col = X.select_dtypes(include=['int64','float64']).columns.tolist()
print("Categorical columns:", cat_col)
print("Numeric columns:", num_col)

#  Encode categorical columns
if len(cat_col) > 0:
    ct = ColumnTransformer(transformers=[
        ('encoder', OneHotEncoder(drop='first'), cat_col)
    ], remainder='passthrough')
    
    X_encoded = ct.fit_transform(X)
    encoded_cols = ct.named_transformers_['encoder'].get_feature_names_out(cat_col)
    all_cols = list(encoded_cols) + num_col
    X_encoded_df = pd.DataFrame(X_encoded, columns=all_cols)
else:
    X_encoded_df = X.copy()

# 5️⃣ Scale numeric columns
num_cols_in_encoded = [col for col in num_col if col in X_encoded_df.columns]
scaler = StandardScaler()
X_encoded_df[num_cols_in_encoded] = scaler.fit_transform(X_encoded_df[num_cols_in_encoded])

#  Train-test split
X_train, X_test, Y_train, Y_test = train_test_split(
    X_encoded_df, Y, test_size=0.2, random_state=42, stratify=Y
)

#  Initialize XGBoost model
xgb_model = XGBClassifier(
    random_state=42,
    n_estimators=200,
    max_depth=5,
    learning_rate=0.1,
    subsample=0.8,
    colsample_bytree=0.8,
    use_label_encoder=False,
    eval_metric='logloss'
)

#  Cross-validation
cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
cv_scores = cross_val_score(xgb_model, X_train, Y_train, cv=cv, scoring='accuracy')
print(f"Cross-Validation Accuracy Scores: {cv_scores}")
print(f"Mean CV Accuracy: {cv_scores.mean():.4f}")

#  Train final model on full training set
xgb_model.fit(X_train, Y_train)

#  Evaluate on test set
y_pred = xgb_model.predict(X_test)
y_proba = xgb_model.predict_proba(X_test)[:,1]

# Confusion Matrix
cm = confusion_matrix(Y_test, y_pred)
plt.figure(figsize=(6,5))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=['No Disease','Heart Disease'],
            yticklabels=['No Disease','Heart Disease'])
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix")
plt.show()

# Classification Report
print("\nClassification Report:\n")
print(classification_report(Y_test, y_pred, target_names=['No Disease','Heart Disease']))

# ROC-AUC Curve
fpr, tpr, thresholds = roc_curve(Y_test, y_proba)
roc_auc = auc(fpr, tpr)

plt.figure(figsize=(6,5))
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (AUC = %0.2f)' % roc_auc)
plt.plot([0,1],[0,1], color='navy', lw=2, linestyle='--')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve')
plt.legend(loc='lower right')
plt.show()
print("ROC-AUC Score:", roc_auc)

# Feature Importance
feat_importances = pd.Series(xgb_model.feature_importances_, index=X_train.columns).sort_values(ascending=False)
plt.figure(figsize=(8,6))
sns.barplot(x=feat_importances[:10], y=feat_importances.index[:10], palette="viridis")
plt.title("Top 10 Important Features for Heart Disease Prediction")
plt.xlabel("Feature Importance Score")
plt.ylabel("Features")
plt.show()
